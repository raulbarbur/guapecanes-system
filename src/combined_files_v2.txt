--- File: bulk-actions.ts (in subfolder: actions) ---

// src/actions/bulk-actions.ts
'use server'

import { prisma } from "@/lib/prisma"

// Definimos qu√© esperamos recibir de cada fila del Excel
type ImportRow = {
  name: string
  categoryName: string
  ownerName: string
  cost: number
  price: number
}

export async function importSingleProduct(data: ImportRow) {
  try {
    // 1. BUSCAR O CREAR CATEGOR√çA (Case Insensitive)
    // Truco: Buscamos primero para no fallar por unique constraint
    let category = await prisma.category.findFirst({
      where: { name: { equals: data.categoryName, mode: 'insensitive' } }
    })

    if (!category) {
      category = await prisma.category.create({
        data: { name: data.categoryName } // Creamos si no existe
      })
    }

    // 2. BUSCAR DUE√ëO (Por nombre exacto o aproximado)
    // Aqu√≠ asumimos que el due√±o YA DEBE EXISTIR. Si no, es riesgoso crearlo auto.
    const owner = await prisma.owner.findFirst({
      where: { name: { equals: data.ownerName, mode: 'insensitive' } }
    })

    if (!owner) {
      return { success: false, error: `Due√±o no encontrado: ${data.ownerName}` }
    }

    // 3. CREAR PRODUCTO Y VARIANTE
    await prisma.$transaction(async (tx) => {
      const newProduct = await tx.product.create({
        data: {
          name: data.name,
          categoryId: category.id,
          ownerId: owner.id,
          isActive: true
        }
      })

      await tx.productVariant.create({
        data: {
          productId: newProduct.id,
          name: "Est√°ndar",
          costPrice: data.cost,
          salePrice: data.price,
          stock: 0, // Siempre nace en 0, luego se hace ingreso de stock
          imageUrl: null 
        }
      })
    })

    return { success: true }

  } catch (error: any) {
    console.error("Error importando:", error)
    return { success: false, error: error.message }
  }
}

--- File: category-actions.ts (in subfolder: actions) ---

// src/actions/category-actions.ts
'use server'

import { prisma } from "@/lib/prisma"
import { revalidatePath } from "next/cache"

export async function createCategory(formData: FormData) {
  const name = formData.get("name") as string

  if (!name) return

  try {
    await prisma.category.create({
      data: { name }
    })
    
    revalidatePath("/categories")
    return { success: true }
  
  } catch (error) {
    // Si el error es porque ya existe (c√≥digo P2002 de Prisma), no hacemos nada
    console.error("Error creando categor√≠a:", error)
    return { success: false, error: "Error al crear (¬øQuiz√°s ya existe?)" }
  }
}

--- File: inventory-actions.ts (in subfolder: actions) ---

// src/actions/inventory-actions.ts
'use server'

import { prisma } from "@/lib/prisma"
import { revalidatePath } from "next/cache"
import { redirect } from "next/navigation"

export async function registerStockMovement(formData: FormData) {
  const variantId = formData.get("variantId") as string
  const quantity = parseInt(formData.get("quantity") as string)
  const reason = formData.get("reason") as string
  // Capturamos el tipo de movimiento del formulario
  const type = formData.get("type") as "ENTRY" | "OWNER_WITHDRAWAL"

  if (!variantId || quantity <= 0 || !type) {
    throw new Error("Datos inv√°lidos")
  }

  try {
    // ‚ö†Ô∏è VALIDACI√ìN CR√çTICA PARA RETIROS
    // Si van a sacar mercader√≠a, primero vemos si alcanza.
    if (type === "OWNER_WITHDRAWAL") {
      const currentVariant = await prisma.productVariant.findUnique({
        where: { id: variantId }
      })

      if (!currentVariant || currentVariant.stock < quantity) {
        // Retornamos un objeto de error en lugar de lanzar excepci√≥n para manejarlo en UI (simple)
        // Nota: En un sistema m√°s avanzado, usar√≠amos try/catch en el componente cliente.
        console.error("Stock insuficiente")
        return { error: `Stock insuficiente. Tienes ${currentVariant?.stock || 0}` }
      }
    }

    await prisma.$transaction([
      // 1. Crear el movimiento hist√≥rico (La auditor√≠a)
      prisma.stockMovement.create({
        data: {
          variantId,
          quantity: type === "ENTRY" ? quantity : -quantity, // Positivo si entra, Negativo si sale
          type: type, // ENTRY o OWNER_WITHDRAWAL
          reason: reason || (type === "ENTRY" ? "Ingreso manual" : "Retiro de due√±o"),
          userId: "sistema",
        }
      }),

      // 2. Actualizar el stock actual (El contador)
      prisma.productVariant.update({
        where: { id: variantId },
        data: {
          stock: type === "ENTRY" 
            ? { increment: quantity } // Si entra, suma
            : { decrement: quantity } // Si sale, resta
        }
      })
    ])

    revalidatePath("/products")
    revalidatePath("/inventory") // Revalidamos la misma p√°gina por si queremos ver cambios

  } catch (error) {
    console.error("Error gestionando stock:", error)
    return { error: "Fall√≥ el movimiento de stock" }
  }

  // Redirigimos para limpiar el formulario
  redirect("/products")
}

--- File: owner-actions.ts (in subfolder: actions) ---

// src/actions/owner-actions.ts
"use server"; // Esto le dice a Next.js: "Ejecutame en el servidor, no en el navegador"

import { prisma } from "@/lib/prisma";
import { revalidatePath } from "next/cache";

export async function createOwner(formData: FormData) {
  // 1. Extraer datos del formulario HTML
  const name = formData.get("name") as string;
  const email = formData.get("email") as string;
  const phone = formData.get("phone") as string;

  // 2. Validaci√≥n b√°sica (nunca conf√≠es en el usuario)
  if (!name) return;

  // 3. Guardar en Base de Datos
  await prisma.owner.create({
    data: {
      name,
      email,
      phone,
      isActive: true,
    },
  });

  // 4. Actualizar la pantalla para mostrar el nuevo dato
  revalidatePath("/owners");
}


--- File: product-actions.ts (in subfolder: actions) ---

// src/actions/product-actions.ts
'use server'

import { prisma } from "@/lib/prisma"
import { revalidatePath } from "next/cache"
import { redirect } from "next/navigation"

export async function createProduct(formData: FormData) {
  // 1. Obtener datos simples
  const name = formData.get("name") as string
  const description = formData.get("description") as string
  const ownerId = formData.get("ownerId") as string
  const categoryId = formData.get("categoryId") as string
  const imageUrl = formData.get("imageUrl") as string // URL de Cloudinary
  
  // 2. Obtener y convertir n√∫meros (Prisma usa Strings para Decimals, pero validamos aqu√≠)
  const costPrice = parseFloat(formData.get("costPrice") as string)
  const salePrice = parseFloat(formData.get("salePrice") as string)

  // Validaciones b√°sicas
  if (!name || !ownerId || !categoryId || !costPrice || !salePrice) {
    throw new Error("Faltan datos obligatorios")
  }

  try {
    // 3. LA TRANSACCI√ìN (Todo o Nada)
    await prisma.$transaction(async (tx) => {
      
      // A. Crear el "Padre" (Producto gen√©rico)
      const newProduct = await tx.product.create({
        data: {
          name,
          description,
          ownerId,
          categoryId,
          isActive: true
        }
      })

      // B. Crear el "Hijo" (Variante inicial)
      // Usamos el ID del padre que acabamos de crear (newProduct.id)
      await tx.productVariant.create({
        data: {
          productId: newProduct.id,
          name: "Est√°ndar", // Por ahora, variante √∫nica por defecto
          imageUrl: imageUrl || null,
          costPrice: costPrice,
          salePrice: salePrice,
          stock: 0 // Regla de oro: Nace con stock 0. Se carga despu√©s.
        }
      })
    })

    // 4. Si todo sali√≥ bien
    revalidatePath("/products")

  } catch (error) {
    console.error("Error creando producto:", error)
    return { error: "Error al guardar el producto" }
  }
  
  // Redirigir al listado (fuera del try/catch)
  redirect("/products")
}

// --- AGREGAR AL FINAL DE src/actions/product-actions.ts ---

export async function updateProduct(formData: FormData) {
  const id = formData.get("id") as string
  const name = formData.get("name") as string
  const description = formData.get("description") as string
  const categoryId = formData.get("categoryId") as string
  const ownerId = formData.get("ownerId") as string
  const costPrice = parseFloat(formData.get("costPrice") as string)
  const salePrice = parseFloat(formData.get("salePrice") as string)
  const imageUrl = formData.get("imageUrl") as string

  if (!id || !name || !costPrice || !salePrice) throw new Error("Datos faltantes")

  try {
    await prisma.$transaction(async (tx) => {
      // 1. Actualizar datos base del producto
      await tx.product.update({
        where: { id },
        data: { name, description, categoryId, ownerId }
      })

      // 2. Actualizar precios en la variante (Asumimos variante √∫nica por ahora)
      // Primero buscamos la variante asociada a este producto
      const variant = await tx.productVariant.findFirst({ where: { productId: id } })
      
      if (variant) {
        await tx.productVariant.update({
          where: { id: variant.id },
          data: {
            costPrice,
            salePrice,
            // Si viene una imagen nueva, la actualizamos. Si viene vac√≠a, NO la tocamos (mantenemos la vieja)
            ...(imageUrl ? { imageUrl } : {}) 
          }
        })
      }
    })

    revalidatePath("/products")
    revalidatePath("/pos") // Importante: actualizar precios en el punto de venta
    return { success: true }

  } catch (error) {
    console.error("Error actualizando:", error)
    return { error: "No se pudo actualizar el producto" }
  }
}

export async function toggleProductStatus(productId: string, currentStatus: boolean) {
  try {
    // REGLA DE ORO: No archivar si hay stock positivo
    if (currentStatus === true) { // Si queremos desactivar...
      const variant = await prisma.productVariant.findFirst({ where: { productId } })
      if (variant && variant.stock > 0) {
        return { error: "No se puede archivar un producto con stock. Hac√© un retiro o ajuste a 0 primero." }
      }
    }

    await prisma.product.update({
      where: { id: productId },
      data: { isActive: !currentStatus }
    })

    revalidatePath("/products")
    revalidatePath("/pos")
    return { success: true }
  } catch (error) {
    return { error: "Error cambiando estado" }
  }
}

--- File: sale-actions.ts (in subfolder: actions) ---

// src/actions/sale-actions.ts
'use server'

import { prisma } from "@/lib/prisma"
import { revalidatePath } from "next/cache"

// Definimos la estructura de lo que esperamos recibir desde el carrito
type CartItem = {
  variantId: string
  quantity: number
}

export async function processSale(cart: CartItem[], totalEstimado: number) {
  if (cart.length === 0) return { error: "El carrito est√° vac√≠o" }

  try {
    await prisma.$transaction(async (tx) => {
      // 1. Calcular el total REAL en el servidor (No confiamos en el frontend)
      let totalReal = 0
      
      // Preparamos los items para guardar
      const saleItemsData = []

      for (const item of cart) {
        // Buscamos el producto en la DB para tener el precio y stock ACTUAL
        const variant = await tx.productVariant.findUnique({
          where: { id: item.variantId },
          include: { product: true }
        })

        if (!variant) throw new Error(`Producto ${item.variantId} no encontrado`)
        
        // Validaci√≥n de Stock Cr√≠tica
        if (variant.stock < item.quantity) {
          throw new Error(`Stock insuficiente para ${variant.product.name}`)
        }

        // Sumamos al total (usando el precio de la DB)
        const subtotal = Number(variant.salePrice) * item.quantity
        totalReal += subtotal

        // Preparamos el item de venta (Snapshot de precios)
        saleItemsData.push({
          variantId: variant.id,
          description: variant.product.name, // Guardamos el nombre por si despu√©s cambia
          quantity: item.quantity,
          costAtSale: variant.costPrice,     // Guardamos el costo hist√≥rico
          priceAtSale: variant.salePrice     // Guardamos el precio hist√≥rico
        })

        // 2. Descontar Stock
        await tx.productVariant.update({
          where: { id: variant.id },
          data: { stock: { decrement: item.quantity } }
        })

        // 3. Auditor√≠a de Movimiento
        await tx.stockMovement.create({
          data: {
            variantId: variant.id,
            quantity: -item.quantity, // Negativo porque sale
            type: "SALE",
            reason: "Venta Mostrador",
            userId: "sistema"
          }
        })
      }

      // 4. Crear la Venta Cabecera
      await tx.sale.create({
        data: {
          total: totalReal,
          paymentMethod: "CASH", // Por ahora fijo efectivo
          status: "COMPLETED",
          items: {
            create: saleItemsData
          }
        }
      })
    })

    revalidatePath("/products")
    revalidatePath("/pos")
    return { success: true }

  } catch (error: any) {
    console.error("Error en venta:", error)
    return { error: error.message || "Error al procesar venta" }
  }
}

// --- AGREGAR ESTO AL FINAL DE: src/actions/sale-actions.ts ---

export async function cancelSale(saleId: string) {
  try {
    await prisma.$transaction(async (tx) => {
      // 1. Buscar la venta y sus items
      const sale = await tx.sale.findUnique({
        where: { id: saleId },
        include: { items: true }
      })

      if (!sale) throw new Error("Venta no encontrada")
      if (sale.status === 'CANCELLED') throw new Error("Ya est√° anulada")

      // 2. Marcar como ANULADA
      await tx.sale.update({
        where: { id: saleId },
        data: { status: 'CANCELLED' }
      })

      // 3. Devolver el stock de cada producto
      for (const item of sale.items) {
        if (item.variantId) {
          // Devolver stock
          await tx.productVariant.update({
            where: { id: item.variantId },
            data: { stock: { increment: item.quantity } }
          })

          // Auditar el movimiento
          await tx.stockMovement.create({
            data: {
              variantId: item.variantId,
              quantity: item.quantity, // Positivo (Entra de nuevo)
              type: 'SALE_CANCELLED',
              reason: `Anulaci√≥n Venta #${sale.id.slice(0, 8)}`,
              userId: 'sistema'
            }
          })
        }
      }
    })

    revalidatePath("/sales")
    revalidatePath("/products") // Para que se vea el stock actualizado
    return { success: true }

  } catch (error: any) {
    return { error: error.message }
  }
}

--- File: settlement-actions.ts (in subfolder: actions) ---

// src/actions/settlement-actions.ts
'use server'

import { prisma } from "@/lib/prisma"
import { revalidatePath } from "next/cache"
import { redirect } from "next/navigation"

export async function createSettlement(formData: FormData) {
  const ownerId = formData.get("ownerId") as string
  
  if (!ownerId) throw new Error("ID de due√±o requerido")

  try {
    // 1. SEGURIDAD: Volvemos a calcular la deuda en el servidor.
    // No confiamos en lo que el frontend dice que hay que pagar.
    const pendingItems = await prisma.saleItem.findMany({
      where: {
        isSettled: false, // Solo lo no pagado
        variant: {
          product: {
            ownerId: ownerId // Solo de este due√±o
          }
        }
      }
    })

    if (pendingItems.length === 0) {
      return { error: "No hay nada pendiente para liquidar." }
    }

    // 2. Calcular total
    const totalToPay = pendingItems.reduce((sum, item) => {
      return sum + (Number(item.costAtSale) * item.quantity)
    }, 0)

    // 3. TRANSACCI√ìN AT√ìMICA (Crear Recibo + Marcar Pagado)
    await prisma.$transaction(async (tx) => {
      // A. Crear la Cabecera de la Rendici√≥n (El "Recibo")
      const newSettlement = await tx.settlement.create({
        data: {
          ownerId,
          totalAmount: totalToPay,
        }
      })

      // B. Marcar cada item como pagado y vincularlo al recibo
      // Usamos updateMany para ser eficientes, filtrando por los IDs que encontramos arriba
      await tx.saleItem.updateMany({
        where: {
          id: { in: pendingItems.map(i => i.id) }
        },
        data: {
          isSettled: true,
          settlementId: newSettlement.id
        }
      })
    })

    revalidatePath("/owners/balance")

  } catch (error) {
    console.error("Error en liquidaci√≥n:", error)
    return { error: "Error al procesar el pago." }
  }

  // 4. Redirigir al balance general (que ahora deber√≠a mostrar deuda 0)
  redirect("/owners/balance")
}

--- File: layout.tsx (in subfolder: app) ---

import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}


--- File: page.tsx (in subfolder: app) ---

import Image from "next/image";

export default function Home() {
  return (
    <div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
      <main className="flex min-h-screen w-full max-w-3xl flex-col items-center justify-between py-32 px-16 bg-white dark:bg-black sm:items-start">
        <Image
          className="dark:invert"
          src="/next.svg"
          alt="Next.js logo"
          width={100}
          height={20}
          priority
        />
        <div className="flex flex-col items-center gap-6 text-center sm:items-start sm:text-left">
          <h1 className="max-w-xs text-3xl font-semibold leading-10 tracking-tight text-black dark:text-zinc-50">
            To get started, edit the page.tsx file.
          </h1>
          <p className="max-w-md text-lg leading-8 text-zinc-600 dark:text-zinc-400">
            Looking for a starting point or more instructions? Head over to{" "}
            <a
              href="https://vercel.com/templates?framework=next.js&utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              className="font-medium text-zinc-950 dark:text-zinc-50"
            >
              Templates
            </a>{" "}
            or the{" "}
            <a
              href="https://nextjs.org/learn?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
              className="font-medium text-zinc-950 dark:text-zinc-50"
            >
              Learning
            </a>{" "}
            center.
          </p>
        </div>
        <div className="flex flex-col gap-4 text-base font-medium sm:flex-row">
          <a
            className="flex h-12 w-full items-center justify-center gap-2 rounded-full bg-foreground px-5 text-background transition-colors hover:bg-[#383838] dark:hover:bg-[#ccc] md:w-[158px]"
            href="https://vercel.com/new?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            <Image
              className="dark:invert"
              src="/vercel.svg"
              alt="Vercel logomark"
              width={16}
              height={16}
            />
            Deploy Now
          </a>
          <a
            className="flex h-12 w-full items-center justify-center rounded-full border border-solid border-black/[.08] px-5 transition-colors hover:border-transparent hover:bg-black/[.04] dark:border-white/[.145] dark:hover:bg-[#1a1a1a] md:w-[158px]"
            href="https://nextjs.org/docs?utm_source=create-next-app&utm_medium=appdir-template-tw&utm_campaign=create-next-app"
            target="_blank"
            rel="noopener noreferrer"
          >
            Documentation
          </a>
        </div>
      </main>
    </div>
  );
}


--- File: page.tsx (in subfolder: app\categories) ---

// src/app/categories/page.tsx
import { createCategory } from "@/actions/category-actions"
import { prisma } from "@/lib/prisma"

export default async function CategoriesPage() {
  const categories = await prisma.category.findMany({
    orderBy: { name: 'asc' } // Orden alfab√©tico
  })

  return (
    <div className="p-10 max-w-2xl mx-auto">
      <h1 className="text-3xl font-bold mb-8">Categor√≠as de Productos</h1>

      {/* FORMULARIO */}
      <div className="bg-white p-6 rounded-lg shadow-md mb-10 border">
        <form action={createCategory} className="flex gap-4">
          <input 
            name="name" 
            type="text" 
            required 
            className="border p-2 rounded flex-1" 
            placeholder="Ej: Alimentos, Accesorios..."
          />
          <button 
            type="submit" 
            className="bg-indigo-600 text-white px-6 py-2 rounded hover:bg-indigo-700"
          >
            Agregar
          </button>
        </form>
      </div>

      {/* LISTADO */}
      <div className="grid grid-cols-2 gap-4">
        {categories.map((cat) => (
          <div key={cat.id} className="border p-4 rounded bg-gray-50 flex justify-between items-center">
            <span className="font-semibold">{cat.name}</span>
            <span className="text-xs text-gray-400">ID: {cat.id.slice(0, 8)}...</span>
          </div>
        ))}
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\dashboard) ---

// src/app/dashboard/page.tsx
import { prisma } from "@/lib/prisma"

export default async function DashboardPage() {
  // 1. DEFINIR EL RANGO DE TIEMPO (ESTE MES)
  const now = new Date()
  const firstDayOfMonth = new Date(now.getFullYear(), now.getMonth(), 1)
  const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1)

  // 2. BUSCAR VENTAS DEL MES (COMPLETADAS)
  const sales = await prisma.sale.findMany({
    where: {
      status: "COMPLETED", // Ignoramos las anuladas
      createdAt: {
        gte: firstDayOfMonth, // Mayor o igual al d√≠a 1
        lt: nextMonth         // Menor estricto al mes que viene
      }
    },
    include: {
      items: true // Necesitamos los items para ver el COSTO
    }
  })

  // 3. CALCULAR M√âTRICAS
  let totalRevenue = 0 // Lo que entr√≥ a caja
  let totalCost = 0    // Lo que le debemos/pagamos a los due√±os
  let itemsSold = 0

  sales.forEach(sale => {
    // Sumamos el total de la venta (Ingreso)
    totalRevenue += Number(sale.total)

    // Sumamos los costos de los items individuales
    sale.items.forEach(item => {
      itemsSold += item.quantity
      // Ojo: Si es un servicio (variantId null), el costo es 0 (o mano de obra, pero asumimos 0 por ahora)
      if (item.variantId) {
        totalCost += Number(item.costAtSale) * item.quantity
      }
    })
  })

  const grossProfit = totalRevenue - totalCost
  const margin = totalRevenue > 0 ? (grossProfit / totalRevenue) * 100 : 0

  return (
    <div className="p-8 max-w-6xl mx-auto">
      <h1 className="text-3xl font-bold mb-2">Tablero de Control</h1>
      <p className="text-gray-500 mb-8">
        Resumen del mes: {firstDayOfMonth.toLocaleDateString('es-AR', { month: 'long', year: 'numeric' })}
      </p>

      {/* TARJETAS DE M√âTRICAS */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-6 mb-10">
        
        {/* CARD 1: VENTAS TOTALES */}
        <div className="bg-white p-6 rounded-lg shadow border-l-4 border-blue-500">
          <p className="text-sm text-gray-500 font-bold uppercase">Ventas Brutas</p>
          <p className="text-3xl font-bold text-gray-800 mt-2">
            ${totalRevenue.toLocaleString()}
          </p>
          <p className="text-xs text-gray-400 mt-1">{sales.length} transacciones</p>
        </div>

        {/* CARD 2: COSTOS (A DUE√ëOS) */}
        <div className="bg-white p-6 rounded-lg shadow border-l-4 border-red-500">
          <p className="text-sm text-gray-500 font-bold uppercase">Costos Mercader√≠a</p>
          <p className="text-3xl font-bold text-red-700 mt-2">
            -${totalCost.toLocaleString()}
          </p>
          <p className="text-xs text-gray-400 mt-1">A pagar a due√±os</p>
        </div>

        {/* CARD 3: GANANCIA BRUTA */}
        <div className="bg-white p-6 rounded-lg shadow border-l-4 border-green-500">
          <p className="text-sm text-gray-500 font-bold uppercase">Ganancia Real</p>
          <p className="text-3xl font-bold text-green-700 mt-2">
            ${grossProfit.toLocaleString()}
          </p>
          <p className="text-xs text-green-600 mt-1">
             Margen: {margin.toFixed(1)}%
          </p>
        </div>

        {/* CARD 4: VOLUMEN */}
        <div className="bg-white p-6 rounded-lg shadow border-l-4 border-purple-500">
          <p className="text-sm text-gray-500 font-bold uppercase">Productos Vendidos</p>
          <p className="text-3xl font-bold text-gray-800 mt-2">
            {itemsSold}
          </p>
          <p className="text-xs text-gray-400 mt-1">Unidades</p>
        </div>
      </div>

      {/* SUGERENCIA VISUAL: Podr√≠amos poner un gr√°fico aqu√≠ a futuro */}
      <div className="bg-indigo-50 p-10 rounded-lg border border-indigo-100 text-center">
        <h3 className="text-indigo-900 font-bold text-lg mb-2">üí° Interpretaci√≥n</h3>
        <p className="text-indigo-700 max-w-2xl mx-auto">
          De cada $100 que entran a la caja, te quedan 
          <span className="font-bold text-xl mx-1">${margin.toFixed(0)}</span> 
          para pagar luz, alquiler y tu sueldo. El resto es de los consignantes.
        </p>
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\inventory) ---

// src/app/inventory/page.tsx
import { prisma } from "@/lib/prisma"
// Importamos la nueva funci√≥n (asegurate de cambiar el nombre en el import tambi√©n si lo cambiaste en el archivo)
import { registerStockMovement } from "@/actions/inventory-actions"

export default async function InventoryPage() {
  const products = await prisma.product.findMany({
    include: { variants: true, owner: true },
    orderBy: { name: 'asc' }
  })

  return (
    <div className="p-8 max-w-2xl mx-auto">
      <h1 className="text-3xl font-bold mb-8">Control de Stock</h1>

      <div className="bg-white p-6 rounded-lg shadow-md border border-gray-200">
        {/* Cambiamos la acci√≥n a la nueva funci√≥n */}
        <form action={registerStockMovement} className="space-y-6">
          
          {/* NUEVO: TIPO DE MOVIMIENTO */}
          <div className="flex gap-4 p-4 bg-gray-50 rounded border">
            <label className="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="type" value="ENTRY" defaultChecked className="w-5 h-5 text-green-600" />
              <span className="font-bold text-green-700">üü¢ Ingreso (Remito)</span>
            </label>
            <label className="flex items-center gap-2 cursor-pointer">
              <input type="radio" name="type" value="OWNER_WITHDRAWAL" className="w-5 h-5 text-orange-600" />
              <span className="font-bold text-orange-700">üü† Retiro de Due√±o</span>
            </label>
          </div>

          {/* SELECCI√ìN DE PRODUCTO */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Producto</label>
            <select name="variantId" required className="w-full border p-3 rounded bg-white">
              <option value="">Seleccionar producto...</option>
              {products.map(p => {
                const v = p.variants[0]
                return (
                  <option key={v.id} value={v.id}>
                    {p.name} (Stock: {v.stock}) - Due√±o: {p.owner.name}
                  </option>
                )
              })}
            </select>
          </div>

          {/* CANTIDAD */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Cantidad</label>
            <input 
              name="quantity" 
              type="number" 
              min="1" 
              required 
              className="w-full border p-3 rounded text-lg font-bold" 
              placeholder="Ej: 5"
            />
          </div>

          {/* MOTIVO */}
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">Nota / Motivo</label>
            <input 
              name="reason" 
              type="text" 
              className="w-full border p-3 rounded" 
              placeholder="Ej: Remito #123 o 'Se lo llev√≥ para evento'"
            />
          </div>

          <button 
            type="submit" 
            className="w-full bg-slate-800 text-white py-3 rounded hover:bg-slate-900 font-bold text-lg"
          >
            Registrar Movimiento
          </button>

        </form>
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\owners) ---

// src/app/owners/page.tsx
import { createOwner } from "@/actions/owner-actions"
import { prisma } from "@/lib/prisma"

export default async function OwnersPage() {
  // Consultamos los due√±os existentes para mostrarlos abajo
  const owners = await prisma.owner.findMany({
    orderBy: { createdAt: 'desc' }
  })

  return (
    <div className="p-10 max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold mb-8">Gesti√≥n de Due√±os</h1>

      {/* FORMULARIO DE ALTA */}
      <div className="bg-gray-100 p-6 rounded-lg shadow-md mb-10">
        <h2 className="text-xl font-semibold mb-4">Nuevo Due√±o</h2>
        {/* Al enviar, ejecutamos la Server Action createOwner */}
        <form action={createOwner} className="flex gap-4 items-end">
          
          <div className="flex flex-col gap-1">
            <label className="text-sm text-gray-600">Nombre *</label>
            <input 
              name="name" 
              type="text" 
              required 
              className="border p-2 rounded" 
              placeholder="Juan P√©rez"
            />
          </div>

          <div className="flex flex-col gap-1">
            <label className="text-sm text-gray-600">Email</label>
            <input 
              name="email" 
              type="email" 
              className="border p-2 rounded" 
              placeholder="juan@mail.com"
            />
          </div>

          <div className="flex flex-col gap-1">
            <label className="text-sm text-gray-600">Tel√©fono</label>
            <input 
              name="phone" 
              type="text" 
              className="border p-2 rounded" 
              placeholder="11 1234 5678"
            />
          </div>

          <button 
            type="submit" 
            className="bg-blue-600 text-white px-6 py-2 rounded hover:bg-blue-700 transition"
          >
            Guardar
          </button>
        </form>
      </div>

      {/* LISTADO DE DUE√ëOS */}
      <div className="grid gap-4">
        {owners.map((owner) => (
          <div key={owner.id} className="border p-4 rounded flex justify-between bg-white shadow-sm">
            <div>
              <p className="font-bold text-lg">{owner.name}</p>
              <p className="text-gray-500 text-sm">{owner.email || "Sin email"} | {owner.phone || "Sin tel√©fono"}</p>
            </div>
            <span className="text-green-600 text-sm bg-green-100 px-2 py-1 rounded h-fit">
              Activo
            </span>
          </div>
        ))}
        
        {owners.length === 0 && (
          <p className="text-gray-500 text-center py-10">No hay due√±os registrados a√∫n.</p>
        )}
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\owners\balance) ---

// src/app/owners/balance/page.tsx
import { prisma } from "@/lib/prisma";
import Link from "next/link";

export default async function OwnersBalancePage() {
  // 1. LA CONSULTA MAESTRA
  // Buscamos due√±os y "buceamos" hasta encontrar sus ventas no pagadas
  const ownersData = await prisma.owner.findMany({
    where: { isActive: true },
    include: {
      products: {
        include: {
          variants: {
            include: {
              saleItems: {
                where: { isSettled: false }, // ‚ö†Ô∏è Solo lo que debemos
              },
            },
          },
        },
      },
    },
  });

  // 2. PROCESAMIENTO DE DATOS (C√°lculo en Servidor)
  // Transformamos la estructura compleja de Prisma en una lista simple para la tabla
  const report = ownersData.map((owner) => {
    let totalDebt = 0;
    let itemsCount = 0;

    // Recorremos todo el √°rbol para sumar
    owner.products.forEach((product) => {
      product.variants.forEach((variant) => {
        variant.saleItems.forEach((item) => {
          // REGLA DE ORO: Usamos costAtSale (Hist√≥rico), no el costo actual
          const debtForThisItem = Number(item.costAtSale) * item.quantity;
          totalDebt += debtForThisItem;
          itemsCount += item.quantity;
        });
      });
    });

    return {
      ownerId: owner.id,
      name: owner.name,
      phone: owner.phone,
      totalDebt,
      itemsCount,
    };
  });

  // Filtramos para mostrar primero los que tienen saldo a favor
  const ownersWithDebt = report
    .filter((r) => r.totalDebt > 0)
    .sort((a, b) => b.totalDebt - a.totalDebt); // Ordenar de mayor deuda a menor

  const ownersClean = report.filter((r) => r.totalDebt === 0);

  return (
    <div className="p-10 max-w-4xl mx-auto">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">
          Estado de Cuenta (Deuda a Consignantes)
        </h1>
        <div className="bg-red-100 text-red-800 px-4 py-2 rounded-lg font-bold border border-red-200">
          Total Deuda: $
          {report.reduce((sum, r) => sum + r.totalDebt, 0).toLocaleString()}
        </div>
      </div>

      {/* TABLA DE DEUDORES */}
      <div className="bg-white rounded-lg shadow overflow-hidden border mb-10">
        <table className="w-full text-left">
          <thead className="bg-gray-800 text-white uppercase text-sm">
            <tr>
              <th className="p-4">Due√±o</th>
              <th className="p-4">Items Vendidos (Sin pagar)</th>
              <th className="p-4">A Pagar</th>
              <th className="p-4">Acci√≥n</th>
            </tr>
          </thead>
          <tbody className="divide-y">
            {ownersWithDebt.map((row) => (
              <tr key={row.ownerId} className="hover:bg-yellow-50 transition">
                <td className="p-4">
                  <p className="font-bold text-lg text-gray-800">{row.name}</p>
                  <p className="text-xs text-gray-500">
                    {row.phone || "Sin tel√©fono"}
                  </p>
                </td>
                <td className="p-4 font-mono text-lg">{row.itemsCount} u.</td>
                <td className="p-4">
                  <span className="text-xl font-bold text-red-600">
                    ${row.totalDebt.toLocaleString()}
                  </span>
                </td>
                <td className="p-4">
                  {/* Este bot√≥n llevar√° al detalle para realizar el pago (Pr√≥ximo paso) */}

                  <Link
                    href={`/owners/settlement/${row.ownerId}`}
                    className="bg-indigo-600 text-white px-4 py-2 rounded text-sm hover:bg-indigo-700 shadow inline-block"
                  >
                    Liquidar (Pagar)
                  </Link>
                </td>
              </tr>
            ))}
          </tbody>
        </table>

        {ownersWithDebt.length === 0 && (
          <div className="p-10 text-center text-gray-500 text-lg">
            ‚úÖ ¬°Excelente! No hay deudas pendientes con los due√±os.
          </div>
        )}
      </div>

      {/* DUE√ëOS AL D√çA (Opcional, para ver que existen) */}
      {ownersClean.length > 0 && (
        <details className="mt-8">
          <summary className="cursor-pointer text-gray-500 font-medium hover:text-gray-700">
            Ver due√±os sin saldo pendiente ({ownersClean.length})
          </summary>
          <div className="grid grid-cols-3 gap-4 mt-4 opacity-75">
            {ownersClean.map((o) => (
              <div
                key={o.ownerId}
                className="border p-3 rounded bg-gray-50 text-sm"
              >
                {o.name}
              </div>
            ))}
          </div>
        </details>
      )}
    </div>
  );
}


--- File: page.tsx (in subfolder: app\owners\settlement\[id]) ---

// src/app/owners/settlement/[id]/page.tsx

import { prisma } from "@/lib/prisma"
import { createSettlement } from "@/actions/settlement-actions"
import Link from "next/link"
import SettlementButton from "@/components/SettlementButton" // üëà Importamos el bot√≥n nuevo

// Definimos que esta p√°gina recibe un ID por URL
interface Props {
  params: Promise<{ id: string }>
}

export default async function SettlementPage({ params }: Props) {
  // 1. Obtenemos el ID de la URL
  const { id } = await params
  
  // 2. Buscamos al due√±o y sus items pendientes (isSettled: false)
  const owner = await prisma.owner.findUnique({
    where: { id },
    include: {
      products: {
        include: {
          variants: {
            include: {
              saleItems: {
                where: { isSettled: false }, // ‚ö†Ô∏è Solo lo que debemos
                include: { sale: true }      // Para ver la fecha
              }
            }
          }
        }
      }
    }
  })

  // Si el ID no existe en la DB
  if (!owner) {
    return (
      <div className="p-10 text-center">
        <h1 className="text-xl text-red-600">Due√±o no encontrado</h1>
        <Link href="/owners/balance" className="text-blue-500 underline">Volver</Link>
      </div>
    )
  }

  // 3. Procesamos los datos para mostrarlos en la tabla
  let totalToPay = 0
  
  // Usamos 'any' en el array temporal para evitar pelear con tipos complejos de Prisma en este paso
  const detailRows: any[] = []

  owner.products.forEach(p => {
    p.variants.forEach(v => {
      v.saleItems.forEach(item => {
        // Usamos costAtSale (lo que val√≠a cuando se vendi√≥)
        const subtotal = Number(item.costAtSale) * item.quantity
        totalToPay += subtotal
        
        detailRows.push({
          id: item.id,
          productName: item.description,
          quantity: item.quantity,
          saleDate: item.sale.createdAt,
          cost: Number(item.costAtSale),
          subtotal
        })
      })
    })
  })

  // Ordenamos por fecha (m√°s viejas primero)
  detailRows.sort((a, b) => a.saleDate.getTime() - b.saleDate.getTime())

  return (
    <div className="p-8 max-w-4xl mx-auto">
      
      {/* CABECERA */}
      <div className="mb-8">
        <Link href="/owners/balance" className="text-blue-600 hover:underline mb-4 block">
          ‚Üê Volver al Balance General
        </Link>
        <h1 className="text-3xl font-bold text-gray-800">
          Liquidaci√≥n: {owner.name}
        </h1>
        <p className="text-gray-500">Revis√° el detalle antes de pagar.</p>
      </div>

      {/* CAJA DE RESUMEN Y ACCI√ìN */}
      <div className="bg-gray-50 p-6 rounded-lg border flex flex-col sm:flex-row justify-between items-center mb-8 gap-4">
        <div>
            <p className="text-sm text-gray-500 uppercase font-bold">Total a Pagar</p>
            <p className="text-4xl font-bold text-green-700">${totalToPay.toLocaleString()}</p>
        </div>
        
        {/* FORMULARIO */}
        {totalToPay > 0 ? (
          <form action={createSettlement}>
            {/* Campo oculto para decirle a la Server Action a qui√©n pagar */}
            <input type="hidden" name="ownerId" value={owner.id} />
            
            {/* Componente Cliente (El bot√≥n interactivo) */}
            <SettlementButton />
            
          </form>
        ) : (
          <div className="bg-green-100 text-green-800 px-4 py-2 rounded font-bold">
             DUE√ëO AL D√çA
          </div>
        )}
      </div>

      {/* TABLA DE DETALLE */}
      <div className="bg-white rounded shadow overflow-hidden border">
        <table className="w-full text-left text-sm">
          <thead className="bg-gray-100 text-gray-700 uppercase">
            <tr>
              <th className="p-3">Fecha Venta</th>
              <th className="p-3">Producto</th>
              <th className="p-3 text-right">Cant.</th>
              <th className="p-3 text-right">Costo Hist√≥rico</th>
              <th className="p-3 text-right">Subtotal</th>
            </tr>
          </thead>
          <tbody className="divide-y">
            {detailRows.map(row => (
              <tr key={row.id} className="hover:bg-gray-50">
                <td className="p-3 text-gray-500">
                    {row.saleDate.toLocaleDateString()}
                </td>
                <td className="p-3 font-medium text-gray-800">
                    {row.productName}
                </td>
                <td className="p-3 text-right">{row.quantity}</td>
                <td className="p-3 text-right text-gray-500">${row.cost}</td>
                <td className="p-3 text-right font-bold text-gray-800">
                    ${row.subtotal}
                </td>
              </tr>
            ))}
          </tbody>
        </table>
        
        {detailRows.length === 0 && (
            <div className="p-10 text-center text-gray-400">
                Este due√±o no tiene ventas pendientes de cobro.
            </div>
        )}
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\pos) ---

// src/app/pos/page.tsx
import { prisma } from "@/lib/prisma"
import PosSystem from "@/components/PosSystem"

export default async function PosPage() {
  // Buscamos productos con stock > 0 (o todos, para mostrar agotados visualmente)
  const products = await prisma.product.findMany({
    where: { isActive: true },
    include: { variants: true, owner: true }
  })

  // Transformamos los datos complejos de Prisma a una estructura simple para el Frontend
  const simpleProducts = products.map(p => {
    const v = p.variants[0] // Asumimos variante √∫nica
    return {
      id: v.id,
      name: p.name,
      price: Number(v.salePrice), // Convertimos Decimal a Number para JS
      stock: v.stock,
      imageUrl: v.imageUrl,
      ownerName: p.owner.name
    }
  })

  return (
    <div className="h-screen flex flex-col p-4 bg-gray-50">
      <header className="mb-4 flex justify-between items-center">
        <h1 className="text-2xl font-bold text-gray-800">Punto de Venta</h1>
        <div className="text-sm text-gray-500">Caja Principal</div>
      </header>
      
      {/* Cargamos el sistema interactivo */}
      <PosSystem products={simpleProducts} />
    </div>
  )
}

--- File: page.tsx (in subfolder: app\products) ---

// src/app/products/page.tsx
import { prisma } from "@/lib/prisma"
import ProductForm from "@/components/ProductForm"
import ProductActions from "@/components/ProductActions" // üëà El componente nuevo
import Link from "next/link"

export default async function ProductsPage() {
  // 1. Datos necesarios para los selectores del formulario
  const owners = await prisma.owner.findMany({ select: { id: true, name: true } })
  const categories = await prisma.category.findMany({ select: { id: true, name: true } })

  // 2. Listado de productos (Traemos TODO para gestionar el inventario)
  const products = await prisma.product.findMany({
    include: {
      variants: true,
      category: true,
      owner: true
    },
    orderBy: { name: 'asc' }
  })

  return (
    <div className="p-8 max-w-7xl mx-auto">
      {/* HEADER */}
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold text-gray-800">Inventario de Productos</h1>
        
        {/* Enlace r√°pido al importador masivo */}
        <Link 
          href="/products/import" 
          className="bg-green-600 text-white px-5 py-2 rounded-lg shadow hover:bg-green-700 font-bold text-sm flex items-center gap-2"
        >
          üìÑ Importar Excel
        </Link>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
        
        {/* COLUMNA IZQUIERDA: FORMULARIO ALTA R√ÅPIDA */}
        <div className="lg:col-span-1">
          <div className="sticky top-4">
             <ProductForm owners={owners} categories={categories} />
          </div>
        </div>

        {/* COLUMNA DERECHA: TABLA DE GESTI√ìN */}
        <div className="lg:col-span-2">
          <div className="bg-white rounded-lg shadow overflow-hidden border border-gray-200">
            <table className="w-full text-sm text-left">
              <thead className="bg-gray-100 text-gray-700 uppercase font-bold text-xs">
                <tr>
                  <th className="px-4 py-3">Producto / Due√±o</th>
                  <th className="px-4 py-3">Categor√≠a</th>
                  <th className="px-4 py-3">Precio</th>
                  <th className="px-4 py-3 text-center">Stock</th>
                  <th className="px-4 py-3 text-center">Acciones</th>
                </tr>
              </thead>
              <tbody className="divide-y divide-gray-100">
                {products.map(p => {
                  const variant = p.variants[0] // Variante principal
                  const isArchived = !p.isActive

                  return (
                    <tr 
                      key={p.id} 
                      className={`transition duration-150
                        ${isArchived 
                            ? 'bg-gray-100 opacity-60 grayscale' // Estilo "desactivado"
                            : 'hover:bg-blue-50 bg-white'
                        }
                      `}
                    >
                      {/* PRODUCTO */}
                      <td className="px-4 py-3">
                        <div className="flex items-center gap-3">
                            {variant?.imageUrl ? (
                            <img src={variant.imageUrl} className="w-10 h-10 object-cover rounded border" />
                            ) : (
                            <div className="w-10 h-10 bg-gray-200 rounded flex items-center justify-center text-xs text-gray-400">
                                Sin foto
                            </div>
                            )}
                            <div>
                                <p className="font-bold text-gray-900 leading-tight">
                                    {p.name}
                                    {isArchived && <span className="text-[10px] text-red-600 ml-2 border border-red-200 px-1 rounded">ARCHIVADO</span>}
                                </p>
                                <p className="text-xs text-gray-500">{p.owner.name}</p>
                            </div>
                        </div>
                      </td>

                      {/* CATEGOR√çA */}
                      <td className="px-4 py-3 text-gray-600">
                        {p.category.name}
                      </td>

                      {/* PRECIO */}
                      <td className="px-4 py-3 font-bold text-green-700 text-base">
                        ${variant?.salePrice.toString()}
                      </td>

                      {/* STOCK */}
                      <td className="px-4 py-3 text-center">
                        {variant?.stock === 0 ? (
                          <span className="text-red-600 bg-red-100 px-2 py-1 rounded text-xs font-bold">AGOTADO</span>
                        ) : (
                          <span className="font-mono font-bold text-gray-700">{variant?.stock}</span>
                        )}
                      </td>

                      {/* ACCIONES (Componente Cliente) */}
                      <td className="px-4 py-3">
                        <div className="flex justify-center">
                            <ProductActions 
                                id={p.id} 
                                isActive={p.isActive} 
                                stock={variant?.stock || 0}
                            />
                        </div>
                      </td>
                    </tr>
                  )
                })}
                
                {products.length === 0 && (
                  <tr>
                    <td colSpan={5} className="text-center py-12 text-gray-500">
                      <p className="text-lg">Tu inventario est√° vac√≠o.</p>
                      <p className="text-sm">¬°Agreg√° el primer producto a la izquierda!</p>
                    </td>
                  </tr>
                )}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  )
}

--- File: page.tsx (in subfolder: app\products\import) ---

import ExcelImporter from "@/components/ExcelImporter"
import Link from "next/link"

export default function ImportPage() {
  return (
    <div className="p-8 max-w-3xl mx-auto">
      <Link href="/products" className="text-blue-600 hover:underline mb-4 block">
        ‚Üê Volver a Productos
      </Link>
      <h1 className="text-3xl font-bold mb-8">Asistente de Importaci√≥n</h1>
      <ExcelImporter />
    </div>
  )
}

--- File: page.tsx (in subfolder: app\products\[id]\edit) ---

// src/app/products/[id]/edit/page.tsx
import { prisma } from "@/lib/prisma"
import ProductForm from "@/components/ProductForm"
import Link from "next/link"

interface Props {
  params: Promise<{ id: string }>
}

export default async function EditProductPage({ params }: Props) {
  const { id } = await params

  // 1. Buscar datos maestros para los selectores
  const owners = await prisma.owner.findMany()
  const categories = await prisma.category.findMany()

  // 2. Buscar el producto a editar
  const product = await prisma.product.findUnique({
    where: { id },
    include: { variants: true }
  })

  if (!product) return <div>Producto no encontrado</div>

  // 3. Preparar los datos para el formulario
  const variant = product.variants[0] // Asumimos variante √∫nica
  const initialData = {
    id: product.id,
    name: product.name,
    description: product.description,
    ownerId: product.ownerId,
    categoryId: product.categoryId,
    costPrice: Number(variant.costPrice),
    salePrice: Number(variant.salePrice),
    imageUrl: variant.imageUrl
  }

  return (
    <div className="p-8 max-w-2xl mx-auto">
        <Link href="/products" className="text-blue-500 mb-4 block">‚Üê Cancelar y Volver</Link>
        <ProductForm 
            owners={owners} 
            categories={categories} 
            initialData={initialData} // üëà Pasamos los datos
        />
    </div>
  )
}

--- File: page.tsx (in subfolder: app\sales) ---

// src/app/sales/page.tsx
import { prisma } from "@/lib/prisma"
import { cancelSale } from "@/actions/sale-actions"
import { revalidatePath } from "next/cache"

export default async function SalesHistoryPage() {
  // Buscamos las ventas, incluyendo los items para mostrar detalles
  const sales = await prisma.sale.findMany({
    include: {
      items: true
    },
    orderBy: { createdAt: 'desc' } // Las m√°s nuevas primero
  })

  // Esta funci√≥n act√∫a como puente entre el bot√≥n y la Server Action
  async function handleCancel(formData: FormData) {
    'use server'
    const saleId = formData.get("saleId") as string
    await cancelSale(saleId)
  }

  return (
    <div className="p-8 max-w-5xl mx-auto">
      <h1 className="text-3xl font-bold mb-8">Historial de Ventas</h1>

      <div className="bg-white rounded-lg shadow overflow-hidden">
        <table className="w-full text-left">
          <thead className="bg-gray-100 text-gray-700 uppercase text-sm">
            <tr>
              <th className="p-4">Fecha / ID</th>
              <th className="p-4">Items</th>
              <th className="p-4">Total</th>
              <th className="p-4">Estado</th>
              <th className="p-4">Acci√≥n</th>
            </tr>
          </thead>
          <tbody className="divide-y">
            {sales.map((sale) => (
              <tr key={sale.id} className={sale.status === 'CANCELLED' ? 'bg-red-50' : 'hover:bg-gray-50'}>
                <td className="p-4">
                  <p className="font-bold">{sale.createdAt.toLocaleDateString()}</p>
                  <p className="text-xs text-gray-500 font-mono">{sale.id.slice(0, 8)}...</p>
                </td>
                
                <td className="p-4">
                  <ul className="text-sm list-disc pl-4">
                    {sale.items.map(item => (
                      <li key={item.id}>
                        {item.quantity} x {item.description}
                      </li>
                    ))}
                  </ul>
                </td>

                <td className="p-4 font-bold text-lg">
                  ${sale.total.toString()}
                </td>

                <td className="p-4">
                  <span className={`px-2 py-1 rounded text-xs font-bold
                    ${sale.status === 'COMPLETED' ? 'bg-green-100 text-green-700' : 'bg-red-200 text-red-800'}
                  `}>
                    {sale.status === 'COMPLETED' ? 'COBRADO' : 'ANULADO'}
                  </span>
                </td>

                <td className="p-4">
                  {sale.status === 'COMPLETED' && (
                    <form action={handleCancel}>
                      <input type="hidden" name="saleId" value={sale.id} />
                      <button 
                        type="submit"
                        className="text-red-600 hover:text-red-800 text-sm font-semibold border border-red-200 px-3 py-1 rounded hover:bg-red-50"
                      >
                        Anular
                      </button>
                    </form>
                  )}
                </td>
              </tr>
            ))}
          </tbody>
        </table>

        {sales.length === 0 && (
          <div className="p-10 text-center text-gray-500">
            No hay ventas registradas a√∫n.
          </div>
        )}
      </div>
    </div>
  )
}

--- File: ExcelImporter.tsx (in subfolder: components) ---

'use client'

import { useState } from "react"
import readXlsxFile from "read-excel-file"
import { importSingleProduct } from "@/actions/bulk-actions"

export default function ExcelImporter() {
  const [rows, setRows] = useState<any[]>([])
  const [processing, setProcessing] = useState(false)
  const [progress, setProgress] = useState({ current: 0, total: 0, errors: 0 })
  const [logs, setLogs] = useState<string[]>([])

  // 1. LEER EL ARCHIVO
  const handleFile = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    try {
      // Leemos el Excel. Asumimos columnas en orden: Nombre, Categoria, Due√±o, Costo, Precio
      const data = await readXlsxFile(file)
      
      // Eliminamos la cabecera (fila 0)
      const cleanData = data.slice(1).map(row => ({
        name: row[0] as string,
        categoryName: row[1] as string,
        ownerName: row[2] as string,
        cost: Number(row[3]),
        price: Number(row[4])
      }))

      setRows(cleanData)
      setLogs(prev => [...prev, `Archivo cargado: ${cleanData.length} productos detectados.`])
    } catch (error) {
      alert("Error leyendo Excel. Asegurate que sea un .xlsx v√°lido.")
    }
  }

  // 2. PROCESAR BUCLE (LOOP)
  const startImport = async () => {
    setProcessing(true)
    setProgress({ current: 0, total: rows.length, errors: 0 })
    setLogs([])

    let successCount = 0
    let errorCount = 0

    // BUCLE SECUENCIAL
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i]
      
      // Validar datos m√≠nimos antes de llamar al server
      if (!row.name || !row.ownerName) {
        setLogs(prev => [...prev, `‚ùå Fila ${i+2}: Faltan datos obligatorios`])
        errorCount++
        continue
      }

      // Llamada al Server Action
      const result = await importSingleProduct(row)

      if (result.success) {
        successCount++
      } else {
        errorCount++
        setLogs(prev => [...prev, `‚ùå Error en "${row.name}": ${result.error}`])
      }

      // Actualizar barra de progreso
      setProgress({ 
        current: i + 1, 
        total: rows.length, 
        errors: errorCount 
      })
    }

    setProcessing(false)
    setLogs(prev => [...prev, `üèÅ FINALIZADO. √âxitos: ${successCount}, Errores: ${errorCount}`])
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow border">
      <h2 className="text-xl font-bold mb-4">Importaci√≥n Masiva (Excel)</h2>
      
      <div className="mb-4 p-4 bg-blue-50 text-blue-800 text-sm rounded">
        <strong>Formato requerido (Columnas):</strong>
        <br />
        1. Nombre Producto | 2. Categor√≠a | 3. Nombre Due√±o | 4. Costo | 5. Precio Venta
      </div>

      {!processing && rows.length === 0 && (
        <input 
          type="file" 
          accept=".xlsx" 
          onChange={handleFile}
          className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:bg-blue-600 file:text-white hover:file:bg-blue-700"
        />
      )}

      {rows.length > 0 && !processing && progress.current === 0 && (
        <div className="space-y-4">
          <p className="font-bold text-lg">{rows.length} productos listos para importar.</p>
          <button 
            onClick={startImport}
            className="w-full bg-green-600 text-white py-3 rounded hover:bg-green-700 font-bold"
          >
            Iniciar Importaci√≥n
          </button>
        </div>
      )}

      {/* BARRA DE PROGRESO */}
      {(processing || progress.current > 0) && (
        <div className="mt-4 space-y-2">
          <div className="flex justify-between text-sm font-bold">
            <span>Progreso: {progress.current} / {progress.total}</span>
            <span className="text-red-600">Errores: {progress.errors}</span>
          </div>
          <div className="w-full bg-gray-200 rounded-full h-4">
            <div 
              className="bg-blue-600 h-4 rounded-full transition-all duration-300" 
              style={{ width: `${(progress.current / progress.total) * 100}%` }}
            ></div>
          </div>
        </div>
      )}

      {/* LOGS DE ERRORES */}
      <div className="mt-6 max-h-40 overflow-y-auto bg-gray-900 text-green-400 p-4 rounded font-mono text-xs">
        {logs.length === 0 ? "Esperando log..." : logs.map((log, i) => (
          <div key={i}>{log}</div>
        ))}
      </div>
    </div>
  )
}

--- File: ImageUpload.tsx (in subfolder: components) ---

// src/components/ImageUpload.tsx
'use client' // Necesario para interactuar con el usuario

import { useState } from "react"

export default function ImageUpload({ onImageUpload }: { onImageUpload: (url: string) => void }) {
  const [uploading, setUploading] = useState(false)
  const [preview, setPreview] = useState<string | null>(null)

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (!file) return

    setUploading(true)

    // 1. Preparar los datos para Cloudinary
    const formData = new FormData()
    formData.append("file", file)
    formData.append("upload_preset", process.env.NEXT_PUBLIC_CLOUDINARY_PRESET!)

    try {
      // 2. Enviar a Cloudinary (Petici√≥n directa desde el navegador)
      const cloudName = process.env.NEXT_PUBLIC_CLOUDINARY_CLOUD_NAME
      const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
        method: "POST",
        body: formData,
      })

      const data = await response.json()

      if (data.secure_url) {
        // 3. √âxito: Guardamos la URL y avisamos al componente padre
        setPreview(data.secure_url)
        onImageUpload(data.secure_url) // üëà Esta funci√≥n viene de afuera
      } else {
        alert("Error al subir imagen")
      }
    } catch (error) {
      console.error(error)
      alert("Error de conexi√≥n al subir imagen")
    } finally {
      setUploading(false)
    }
  }

  return (
    <div className="flex flex-col gap-2">
      <label className="text-sm font-medium text-gray-700">Imagen del Producto</label>
      
      <div className="flex items-center gap-4">
        {/* Input de archivo */}
        <input 
          type="file" 
          accept="image/*"
          onChange={handleFileChange}
          disabled={uploading}
          className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
        />
        
        {/* Indicador de carga */}
        {uploading && <span className="text-sm text-blue-600">Subiendo...</span>}
      </div>

      {/* Previsualizaci√≥n */}
      {preview && (
        <div className="mt-2">
          <img src={preview} alt="Vista previa" className="h-32 w-32 object-cover rounded-md border" />
        </div>
      )}
    </div>
  )
}

--- File: PosSystem.tsx (in subfolder: components) ---

// src/components/PosSystem.tsx
'use client'

import { useState } from "react"
import { processSale } from "@/actions/sale-actions"

type ProductType = {
  id: string
  name: string
  price: number
  stock: number
  imageUrl: string | null
  ownerName: string
}

export default function PosSystem({ products }: { products: ProductType[] }) {
  const [cart, setCart] = useState<{ product: ProductType; quantity: number }[]>([])
  const [loading, setLoading] = useState(false)

  const addToCart = (product: ProductType) => {
    if (product.stock <= 0) return alert("Sin stock")

    setCart(currentCart => {
      const existing = currentCart.find(item => item.product.id === product.id)
      if (existing) {
        if (existing.quantity >= product.stock) {
          alert("No hay m√°s stock disponible")
          return currentCart
        }
        return currentCart.map(item => 
          item.product.id === product.id 
            ? { ...item, quantity: item.quantity + 1 } 
            : item
        )
      }
      return [...currentCart, { product, quantity: 1 }]
    })
  }

  const total = cart.reduce((sum, item) => sum + (item.product.price * item.quantity), 0)

  const handleCheckout = async () => {
    if (!confirm(`¬øConfirmar venta por $${total}?`)) return
    
    setLoading(true)
    
    const payload = cart.map(item => ({
      variantId: item.product.id,
      quantity: item.quantity
    }))

    const result = await processSale(payload, total)
    
    setLoading(false)

    if (result.success) {
      alert("¬°Venta Exitosa!")
      setCart([]) 
    } else {
      alert("Error: " + result.error)
    }
  }

  return (
    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 pb-20"> {/* pb-20 da espacio abajo */}
      
      {/* IZQUIERDA: GRILLA DE PRODUCTOS */}
      <div className="md:col-span-2">
        <div className="grid grid-cols-2 lg:grid-cols-3 gap-4">
          {products.map(p => (
            <button 
              key={p.id}
              onClick={() => addToCart(p)}
              disabled={p.stock === 0}
              className={`p-4 border rounded-lg text-left transition shadow-sm flex flex-col gap-2 min-h-[200px]
                ${p.stock === 0 ? 'bg-gray-100 opacity-50 cursor-not-allowed' : 'bg-white hover:border-blue-500 hover:shadow-md'}
              `}
            >
              {p.imageUrl ? (
                <img src={p.imageUrl} alt={p.name} className="w-full h-32 object-cover rounded mb-2" />
              ) : (
                <div className="w-full h-32 bg-gray-200 rounded mb-2 flex items-center justify-center text-gray-400">Sin foto</div>
              )}
              <h3 className="font-bold text-gray-800 leading-tight">{p.name}</h3>
              <div className="flex justify-between items-center w-full mt-auto">
                <span className="text-blue-600 font-bold">${p.price}</span>
                <span className="text-xs text-gray-500">Stock: {p.stock}</span>
              </div>
            </button>
          ))}
        </div>
      </div>

      {/* DERECHA: TICKET / CARRITO (Sticky para que baje contigo) */}
      <div className="md:col-span-1">
        <div className="bg-white border rounded-lg shadow-lg sticky top-4">
          <div className="p-4 border-b bg-gray-50">
            <h2 className="font-bold text-xl">Ticket Actual</h2>
          </div>
          
          <div className="p-4 space-y-4 max-h-[400px] overflow-y-auto">
            {cart.length === 0 && (
              <p className="text-gray-400 text-center py-10">El carrito est√° vac√≠o.<br/>Seleccion√° productos de la izquierda.</p>
            )}
            {cart.map((item, index) => (
              <div key={index} className="flex justify-between items-center border-b pb-2">
                <div>
                  <p className="font-medium">{item.product.name}</p>
                  <p className="text-sm text-gray-500">{item.quantity} x ${item.product.price}</p>
                </div>
                <span className="font-bold">${item.quantity * item.product.price}</span>
              </div>
            ))}
          </div>

          {/* ZONA DE COBRO */}
          <div className="p-6 bg-gray-900 text-white rounded-b-lg">
            <div className="flex justify-between text-2xl font-bold mb-4">
              <span>Total</span>
              <span>${total}</span>
            </div>
            <button 
              onClick={handleCheckout}
              disabled={cart.length === 0 || loading}
              className={`w-full py-4 rounded font-bold text-xl transition
                ${cart.length === 0 ? 'bg-gray-600 cursor-not-allowed text-gray-400' : 'bg-green-500 hover:bg-green-600 text-white'}
              `}
            >
              {loading ? "Procesando..." : "COBRAR"}
            </button>
          </div>
        </div>
      </div>
    </div>
  )
}

--- File: ProductActions.tsx (in subfolder: components) ---

// src/components/ProductActions.tsx
'use client'

import { toggleProductStatus } from "@/actions/product-actions"
import Link from "next/link"
import { useRouter } from "next/navigation"

export default function ProductActions({ id, isActive, stock }: { id: string, isActive: boolean, stock: number }) {
  const router = useRouter()

  const handleToggle = async () => {
    if (isActive && stock > 0) {
        alert("‚ö†Ô∏è No pod√©s archivar un producto con stock.\nHac√© un retiro o ajuste a 0 primero.")
        return
    }

    if (!confirm(isActive ? "¬øArchivar producto?" : "¬øReactivar producto?")) return

    const res = await toggleProductStatus(id, isActive)
    if (res.error) alert(res.error)
    else router.refresh()
  }

  return (
    <div className="flex gap-2">
      {/* Bot√≥n EDITAR (Link simple) */}
      <Link 
        href={`/products/${id}/edit`} 
        className="px-3 py-1 bg-blue-100 text-blue-700 rounded text-xs font-bold hover:bg-blue-200"
      >
        EDITAR
      </Link>

      {/* Bot√≥n ARCHIVAR/ACTIVAR */}
      <button
        onClick={handleToggle}
        className={`px-3 py-1 rounded text-xs font-bold border transition
          ${isActive 
            ? 'bg-white text-red-600 border-red-200 hover:bg-red-50' 
            : 'bg-green-100 text-green-700 border-transparent hover:bg-green-200'
          }
        `}
      >
        {isActive ? "ARCHIVAR" : "ACTIVAR"}
      </button>
    </div>
  )
}

--- File: ProductForm.tsx (in subfolder: components) ---

// src/components/ProductForm.tsx
'use client'

import { useState } from "react"
import { createProduct, updateProduct } from "@/actions/product-actions" // üëà Importamos update
import ImageUpload from "./ImageUpload"
import { useRouter } from "next/navigation" // Para volver atr√°s despu√©s de editar

type Props = {
  owners: { id: string; name: string }[]
  categories: { id: string; name: string }[]
  // üëá NUEVO: Datos opcionales para edici√≥n
  initialData?: {
    id: string
    name: string
    description: string | null
    ownerId: string
    categoryId: string
    costPrice: number
    salePrice: number
    imageUrl: string | null
  }
}

export default function ProductForm({ owners, categories, initialData }: Props) {
  const router = useRouter()
  const [imageUrl, setImageUrl] = useState(initialData?.imageUrl || "")
  
  // Funci√≥n wrapper para manejar la redirecci√≥n post-guardado si es edici√≥n
  const handleSubmit = async (formData: FormData) => {
    if (initialData) {
        // MODO EDICI√ìN
        formData.append("id", initialData.id) // Agregamos el ID oculto
        await updateProduct(formData)
        alert("Producto actualizado correctamente")
        router.push("/products") // Volver al listado
        router.refresh() // Refrescar datos visuales
    } else {
        // MODO CREACI√ìN
        await createProduct(formData)
        // createProduct ya hace redirect, no hace falta l√≥gica aqu√≠
    }
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow-md max-w-2xl mx-auto border">
      <h2 className="text-xl font-bold mb-6">
        {initialData ? "Editar Producto" : "Nuevo Producto"}
      </h2>
      
      <form action={handleSubmit} className="space-y-4">
        
        {/* Nombre */}
        <div>
          <label className="block text-sm font-medium text-gray-700">Nombre *</label>
          <input 
            name="name" 
            defaultValue={initialData?.name} // üëà Pre-carga
            type="text" 
            required 
            className="w-full border p-2 rounded" 
          />
        </div>

        {/* Descripci√≥n */}
        <div>
          <label className="block text-sm font-medium text-gray-700">Descripci√≥n</label>
          <textarea 
            name="description" 
            defaultValue={initialData?.description || ""} 
            className="w-full border p-2 rounded" 
            rows={2} 
          />
        </div>

        {/* Selectores */}
        <div className="grid grid-cols-2 gap-4">
          <div>
            <label className="block text-sm font-medium text-gray-700">Due√±o *</label>
            <select 
              name="ownerId" 
              defaultValue={initialData?.ownerId || ""} 
              required 
              className="w-full border p-2 rounded bg-white"
            >
              <option value="">Seleccionar...</option>
              {owners.map(o => (
                <option key={o.id} value={o.id}>{o.name}</option>
              ))}
            </select>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700">Categor√≠a *</label>
            <select 
              name="categoryId" 
              defaultValue={initialData?.categoryId || ""} 
              required 
              className="w-full border p-2 rounded bg-white"
            >
              <option value="">Seleccionar...</option>
              {categories.map(c => (
                <option key={c.id} value={c.id}>{c.name}</option>
              ))}
            </select>
          </div>
        </div>

        {/* Precios */}
        <div className="grid grid-cols-2 gap-4 bg-gray-50 p-4 rounded">
          <div>
            <label className="block text-sm font-medium text-gray-700">Costo (Due√±o) *</label>
            <input 
                name="costPrice" 
                defaultValue={initialData?.costPrice} 
                type="number" 
                step="0.01" 
                required 
                className="w-full border p-2 rounded" 
            />
          </div>
          <div>
            <label className="block text-sm font-medium text-gray-700">Precio Venta *</label>
            <input 
                name="salePrice" 
                defaultValue={initialData?.salePrice} 
                type="number" 
                step="0.01" 
                required 
                className="w-full border p-2 rounded" 
            />
          </div>
        </div>

        {/* Imagen */}
        <div className="border-t pt-4">
          {imageUrl && (
            <div className="mb-2">
                <p className="text-xs text-gray-500 mb-1">Imagen Actual:</p>
                <img src={imageUrl} alt="Actual" className="w-20 h-20 object-cover rounded border" />
            </div>
          )}
          <ImageUpload onImageUpload={(url) => setImageUrl(url)} />
          <input type="hidden" name="imageUrl" value={imageUrl} />
        </div>

        <button type="submit" className="w-full bg-blue-600 text-white py-3 rounded hover:bg-blue-700 font-bold">
          {initialData ? "Actualizar Cambios" : "Guardar Producto"}
        </button>

      </form>
    </div>
  )
}

--- File: SettlementButton.tsx (in subfolder: components) ---

// src/components/SettlementButton.tsx
'use client' // üëà Esto permite usar onClick y hooks

import { useFormStatus } from "react-dom"

export default function SettlementButton() {
  // useFormStatus detecta si la Server Action se est√° ejecutando
  const { pending } = useFormStatus()

  const handleClick = (e: React.MouseEvent<HTMLButtonElement>) => {
    // Confirmaci√≥n nativa del navegador
    const confirmed = confirm("¬øEst√°s seguro de que vas a entregar el dinero?\n\nEsta acci√≥n marcar√° los items como PAGADOS y no se puede deshacer f√°cilmente.")
    
    if (!confirmed) {
      e.preventDefault() // Cancela el env√≠o del formulario
    }
  }

  return (
    <button
      type="submit"
      onClick={handleClick}
      disabled={pending}
      className={`
        px-8 py-3 rounded-lg font-bold text-lg shadow-lg transition transform 
        ${pending 
          ? 'bg-gray-400 cursor-not-allowed' 
          : 'bg-green-600 hover:bg-green-700 hover:scale-105 text-white'
        }
      `}
    >
      {pending ? "Procesando..." : "‚úÖ Confirmar Pago"}
    </button>
  )
}

--- File: prisma.ts (in subfolder: lib) ---

// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

--- File: schema.prisma (in subfolder: TEMP\prisma) ---

// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS ---
enum Role {
  ADMIN
  STAFF
}

enum StockMovementType {
  ENTRY           // Ingreso (Remito)
  SALE            // Venta (Baja autom√°tica)
  ADJUSTMENT      // Ajuste manual (+/- por error/rotura)
  OWNER_WITHDRAWAL // Retiro del due√±o (Baja sin deuda)
  RETURN          // Devoluci√≥n de cliente (Alta de stock)
  SALE_CANCELLED  // Restauraci√≥n por anulaci√≥n (Alta)
}

enum ApptStatus {
  PENDING
  CONFIRMED
  COMPLETED     // Ya realizado
  BILLED        // Ya cobrado (convertido a venta)
  CANCELLED
}

// --- USUARIOS ---
model User {
  id        String   @id @default(uuid())
  email     String   @unique
  password  String   // Hashed
  name      String
  role      Role     @default(STAFF)
  createdAt DateTime @default(now())
}

// --- CAT√ÅLOGO ---
model Owner {
  id                 String    @id @default(uuid())
  name               String
  phone              String?
  email              String?
  isActive           Boolean   @default(true) 
  createdAt          DateTime  @default(now())
  products           Product[]
  settlements        Settlement[]
  balanceAdjustments BalanceAdjustment[] 
}

model Category {
  id       String    @id @default(uuid())
  name     String    @unique 
  products Product[]
}

model Product {
  id          String    @id @default(uuid())
  name        String
  description String?
  tags        String[]  // Indexar GIN
  ownerId     String
  owner       Owner     @relation(fields: [ownerId], references: [id])
  categoryId  String
  category    Category  @relation(fields: [categoryId], references: [id])
  variants    ProductVariant[]
  isActive    Boolean   @default(true)
}

model ProductVariant {
  id        String   @id @default(uuid())
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  name      String   // "S - Rojo"
  imageUrl  String?  // URL de Cloudinary
  
  // PRECIOS FLOTANTES (Valor actual de mercado)
  costPrice Decimal  @db.Decimal(10, 2) 
  salePrice Decimal  @db.Decimal(10, 2)
  stock     Int      @default(0)
  
  stockMovements StockMovement[]
  saleItems      SaleItem[]

  @@unique([productId, name]) 
}

// --- INVENTARIO ---
model StockMovement {
  id          String            @id @default(uuid())
  variantId   String
  variant     ProductVariant    @relation(fields: [variantId], references: [id])
  quantity    Int               // +/- 
  type        StockMovementType
  reason      String?
  userId      String            // Auditor√≠a
  createdAt   DateTime          @default(now())
}

// --- VENTAS ---
model Sale {
  id            String        @id @default(uuid())
  total         Decimal       @db.Decimal(10, 2)
  paymentMethod String        // CASH, TRANSFER, MIXED
  status        String        @default("COMPLETED") // COMPLETED, CANCELLED
  createdAt     DateTime      @default(now())
  items         SaleItem[]
}

model SaleItem {
  id            String         @id @default(uuid())
  saleId        String
  sale          Sale           @relation(fields: [saleId], references: [id])
  variantId     String?        // Null si es servicio
  variant       ProductVariant? @relation(fields: [variantId], references: [id])
  description   String         // Nombre del producto o servicio al momento de venta
  quantity      Int
  
  // SNAPSHOT (Valor congelado al vender)
  costAtSale    Decimal        @db.Decimal(10, 2)
  priceAtSale   Decimal        @db.Decimal(10, 2)
  
  // ESTADO FINANCIERO
  isSettled     Boolean        @default(false) 
  settlementId  String?
  settlement    Settlement?    @relation(fields: [settlementId], references: [id])
}

// --- FINANZAS (RENDICIONES) ---
model Settlement {
  id          String   @id @default(uuid())
  ownerId     String
  owner       Owner    @relation(fields: [ownerId], references: [id])
  totalAmount Decimal  @db.Decimal(10, 2) // Total pagado
  createdAt   DateTime @default(now())
  items       SaleItem[]
  adjustments BalanceAdjustment[]
}

model BalanceAdjustment {
  id           String      @id @default(uuid())
  ownerId      String
  owner        Owner       @relation(fields: [ownerId], references: [id])
  amount       Decimal     @db.Decimal(10, 2) // Negativo = Cr√©dito a favor Local
  description  String      // "Devoluci√≥n Venta #123"
  isApplied    Boolean     @default(false)
  settlementId String?
  settlement   Settlement? @relation(fields: [settlementId], references: [id])
  createdAt    DateTime    @default(now())
}

// --- SERVICIOS ---
model Pet {
  id          String   @id @default(uuid())
  name        String
  ownerName   String
  ownerPhone  String?
  breed       String?
  notes       String?  // Notas generales
  appointments Appointment[]
  groomingNotes GroomingNote[]
}

model Appointment {
  id        String     @id @default(uuid())
  petId     String
  pet       Pet        @relation(fields: [petId], references: [id])
  startTime DateTime
  endTime   DateTime
  status    ApptStatus @default(PENDING)
  price     Decimal?   @db.Decimal(10, 2)
}

model GroomingNote {
  id        String   @id @default(uuid())
  petId     String
  pet       Pet      @relation(fields: [petId], references: [id])
  content   String   @db.Text
  appointmentId String? // V√≠nculo opcional
  createdAt DateTime @default(now())
}


--- File: migration.sql (in subfolder: TEMP\prisma\migrations\20260109022200_init_db) ---

-- CreateEnum
CREATE TYPE "Role" AS ENUM ('ADMIN', 'STAFF');

-- CreateEnum
CREATE TYPE "StockMovementType" AS ENUM ('ENTRY', 'SALE', 'ADJUSTMENT', 'OWNER_WITHDRAWAL', 'RETURN', 'SALE_CANCELLED');

-- CreateEnum
CREATE TYPE "ApptStatus" AS ENUM ('PENDING', 'CONFIRMED', 'COMPLETED', 'BILLED', 'CANCELLED');

-- CreateTable
CREATE TABLE "User" (
    "id" TEXT NOT NULL,
    "email" TEXT NOT NULL,
    "password" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "role" "Role" NOT NULL DEFAULT 'STAFF',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Owner" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "phone" TEXT,
    "email" TEXT,
    "isActive" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Owner_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Category" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,

    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Product" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "description" TEXT,
    "tags" TEXT[],
    "ownerId" TEXT NOT NULL,
    "categoryId" TEXT NOT NULL,
    "isActive" BOOLEAN NOT NULL DEFAULT true,

    CONSTRAINT "Product_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "ProductVariant" (
    "id" TEXT NOT NULL,
    "productId" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "imageUrl" TEXT,
    "costPrice" DECIMAL(10,2) NOT NULL,
    "salePrice" DECIMAL(10,2) NOT NULL,
    "stock" INTEGER NOT NULL DEFAULT 0,

    CONSTRAINT "ProductVariant_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "StockMovement" (
    "id" TEXT NOT NULL,
    "variantId" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "type" "StockMovementType" NOT NULL,
    "reason" TEXT,
    "userId" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "StockMovement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Sale" (
    "id" TEXT NOT NULL,
    "total" DECIMAL(10,2) NOT NULL,
    "paymentMethod" TEXT NOT NULL,
    "status" TEXT NOT NULL DEFAULT 'COMPLETED',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Sale_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "SaleItem" (
    "id" TEXT NOT NULL,
    "saleId" TEXT NOT NULL,
    "variantId" TEXT,
    "description" TEXT NOT NULL,
    "quantity" INTEGER NOT NULL,
    "costAtSale" DECIMAL(10,2) NOT NULL,
    "priceAtSale" DECIMAL(10,2) NOT NULL,
    "isSettled" BOOLEAN NOT NULL DEFAULT false,
    "settlementId" TEXT,

    CONSTRAINT "SaleItem_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Settlement" (
    "id" TEXT NOT NULL,
    "ownerId" TEXT NOT NULL,
    "totalAmount" DECIMAL(10,2) NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "Settlement_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "BalanceAdjustment" (
    "id" TEXT NOT NULL,
    "ownerId" TEXT NOT NULL,
    "amount" DECIMAL(10,2) NOT NULL,
    "description" TEXT NOT NULL,
    "isApplied" BOOLEAN NOT NULL DEFAULT false,
    "settlementId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "BalanceAdjustment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Pet" (
    "id" TEXT NOT NULL,
    "name" TEXT NOT NULL,
    "ownerName" TEXT NOT NULL,
    "ownerPhone" TEXT,
    "breed" TEXT,
    "notes" TEXT,

    CONSTRAINT "Pet_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Appointment" (
    "id" TEXT NOT NULL,
    "petId" TEXT NOT NULL,
    "startTime" TIMESTAMP(3) NOT NULL,
    "endTime" TIMESTAMP(3) NOT NULL,
    "status" "ApptStatus" NOT NULL DEFAULT 'PENDING',
    "price" DECIMAL(10,2),

    CONSTRAINT "Appointment_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "GroomingNote" (
    "id" TEXT NOT NULL,
    "petId" TEXT NOT NULL,
    "content" TEXT NOT NULL,
    "appointmentId" TEXT,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "GroomingNote_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- CreateIndex
CREATE UNIQUE INDEX "Category_name_key" ON "Category"("name");

-- CreateIndex
CREATE UNIQUE INDEX "ProductVariant_productId_name_key" ON "ProductVariant"("productId", "name");

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "Owner"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Product" ADD CONSTRAINT "Product_categoryId_fkey" FOREIGN KEY ("categoryId") REFERENCES "Category"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "ProductVariant" ADD CONSTRAINT "ProductVariant_productId_fkey" FOREIGN KEY ("productId") REFERENCES "Product"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "StockMovement" ADD CONSTRAINT "StockMovement_variantId_fkey" FOREIGN KEY ("variantId") REFERENCES "ProductVariant"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SaleItem" ADD CONSTRAINT "SaleItem_saleId_fkey" FOREIGN KEY ("saleId") REFERENCES "Sale"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SaleItem" ADD CONSTRAINT "SaleItem_variantId_fkey" FOREIGN KEY ("variantId") REFERENCES "ProductVariant"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "SaleItem" ADD CONSTRAINT "SaleItem_settlementId_fkey" FOREIGN KEY ("settlementId") REFERENCES "Settlement"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Settlement" ADD CONSTRAINT "Settlement_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "Owner"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BalanceAdjustment" ADD CONSTRAINT "BalanceAdjustment_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "Owner"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "BalanceAdjustment" ADD CONSTRAINT "BalanceAdjustment_settlementId_fkey" FOREIGN KEY ("settlementId") REFERENCES "Settlement"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Appointment" ADD CONSTRAINT "Appointment_petId_fkey" FOREIGN KEY ("petId") REFERENCES "Pet"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "GroomingNote" ADD CONSTRAINT "GroomingNote_petId_fkey" FOREIGN KEY ("petId") REFERENCES "Pet"("id") ON DELETE RESTRICT ON UPDATE CASCADE;


